# 重复消费、顺序消费、分布式事务

## 消息队列的消息重复消费

### 什么是消息重复消费

- 消息**重复消费**是使用消息队列之后，必须要考虑的一个问题，也是较为 Problem solving 的问题，在开发过程中，但凡用到了消息队列，第一时间要考虑的就是**重复消费**的问题。

### 为什么会消息重复消费

- 假设有这样一个场景，用户下单成功后，我需要去一个活动页面给他加**GMV**(销售总额)，最后根据他的GMV去给他发奖励，这是电商活动很常见的玩法。
- 类似下单金额到某个梯度，给你返回对应梯度的奖励
- 这样的活动百分百是用**异步**去加的，不然一个用户下一单就给他加一下，那就意味着对那张表就要操作一下，你考虑下双十一当天多少次对这个表操作？这数据库或者缓存都顶不住吧。
- 而且大家应该也有这样的体会，在你下单之后马上去看一些活动页面，有时候马上就有了，有时候却延迟很久，这个速度**取决于消息队列的消费速度**，消费堵塞了自然看到的就慢了。
- 你下个单**支付成功**你就发个消息出去，上面那个活动的开发人员就监听你的**支付成功消息**，那我就去我活动**GMV**表里给你加上去，到这里大家可能觉得顺理成章。

![]( https://raw.githubusercontent.com/jingdomaaa/Java-learning-record/master/image/MQ/MQ_problem_solving1.png )

- **但是**一般消息队列的使用都是有**重试机制**的，就是说下游的业务发生异常了，会输出异常并且要求你重发一次。

- 不过这个活动这里发生错误，要求重发肯定没问题，但是不止一个服务在监听这个消息，还有**别的服务也在监听**，那就会出现系统**本来是成功的，却重发了**。

  ![]( https://raw.githubusercontent.com/jingdomaaa/Java-learning-record/master/image/MQ/MQ_problem_solving2.png )

- 就好比上面这样，**优惠券系统处理失败**了，这个系统肯定要求**重发**一次这个消息，优惠券的系统重新接收并且处理成功了，但是其他的积分等服务**也监听了这个消息**，那就可能出现活动系统给用户的GMV添加了两次、积分扣两次这种情况。

- 现实中其实重试是很正常的，**服务的网络波动**，**开发人员代码bug**还有**数据问题等**都可能导致处理失败要求重发的。

### 如何解决消息重复消费

- 通过**接口幂等**保证消息一致性

  > 幂等(idempotent，idempotence)是一个数学与计算机概念，常见于抽象代数中。
  >
  > 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。
  >
  > 幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。
  >
  > 例如，"setTrue()"函数就是一个幂等函数，无论多次执行，其结果都是一样的，更复杂的操作幂等保证是利用唯一交易号（流水号）实现。

通俗来说就是**同样的参数调用接口，调用多少次结果都是一个**，加GMV同一个订单号加一次是多少钱加n次还是多少钱。流程如下图：

![]( https://raw.githubusercontent.com/jingdomaaa/Java-learning-record/master/image/MQ/MQ_problem_solving3.png )

### 如何保证已解决

- 一般幂等需要分场景考虑，看是强校验还是弱校验，比如跟金钱相关的场景那就很关键，就做强校验，不是很重要的场景就做弱校验。

#### 强校验

- 比如监听到用户支付成功的消息，监听到了去加GMV就要调用加GMV的接口，那在加GMV接口下面再调用一个加流水的接口，**两个放在一个事务里，成功一起成功，失败一起失败。**
- 每次消息过来都要拿着**订单号+业务场景这样的唯一标识**（比如天猫双十一活动）去流水表查，看看有没有这条流水，有就直接return不要走下面的流程了，没有就执行后面的逻辑。
- 之所以用**流水表**，是因为涉及到金钱这样的活动，有啥问题后面也可以去流水表对账，还有就是帮助开发人员定位问题。

```java
/**
  *强校验幂等伪代码展示,这都是简单的伪代码,真实情况复杂一点,但是大的逻辑是这样
  *
  *@param orderId
  *@Author: jingdom
  */
public void process(String orderId) {
    try {
        //查询这个订单是否存在这个活动加GMV的流水
        Object gmvFlow = getFlowByOrderId("addGmv" + orderId);
        if (Objects.isNull(gmvFlow)) {
            //不存在流水,去加GMV和加流水,注意这两个在一个事务,回滚就一起回滚了
            addGmvAndFlow(orderId);
        } else {
            //存在流水证明加过了,返回就好了
            return;
        }
    } catch (Exception e) {
        //发送异常,触发消息队列框架重试机制
    }
}
```

#### 弱校验

- 这个简单，一些不重要的场景,比如给谁发短信啥的，我就把这个id+场景唯一标识作为**Redis**的key，放到缓存里面失效时间看你场景，**一定时间内**的这个消息就去**Redis**判断。
- 用KV就算消息丢失了可能这样的场景也没关系，反正丢条**无关痛痒**的通知短信（你敢说你没验证码短信丢失的情况？）。
- 还有很多公司的弱校验用token啊什么的，反正花样很多，但是**重要的场景一定要强校验**，真正查问题的时候没有在磁盘持久化的数据，心里还是空空的。

## 消息顺序消费

### 什么是消息顺序消费

- 说实话顺序消费这里很难介绍，开发过程中这样的场景不多，网上更多的都是介绍**binlog**的同步，好像更多的场景就没了。
- 一般都是**同个业务场景下不同几个操作的消息同时过去**，本身顺序是对的，但是你发出去的时候同时发出去了。消费的时候却乱掉了，这样就有问题了。
- 电商活动数据量大的时候数据同步压力还是很大的，有时候数据量大的表需要同步几个亿数据。（并不是主从同步，主从延迟大的话会有问题，可能是从数据库或者主数据库同步到**备库**）
- 这种情况我们都是放到队列里面去，然后慢慢消费的，那问题就来了呀，我们在数据库同时对一个id的数据进行了增、改、删三个操作，但是消息发过去的时候变成了改、删、增，这样数据就不对了。本来一条数据应该删掉了，结果你那却还在，这不是**出大问题**。

![]( https://raw.githubusercontent.com/jingdomaaa/Java-learning-record/master/image/MQ/MQ_problem_solving4.png )

- 两者结果完全不一样了。

### 如何解决消息顺序消费

- 简单说一下使用**RoketMQ**里面的一个简单实现。
- Tip：为什么要用**RocketMQ**举例呢，这个是阿里开源的，很多公司都有使用，具体细节后面会在**RocketMQ**和**Kafka**各自的章节说到。

- 生产者消费者一般需要保证顺序消息的话，可能就是一个业务场景下的，比如订单的创建、支付、发货、收货。
- 那这些东西是不是一个订单号呢？一个订单肯定是一个订单号的，那就简单了。
- **一个topic下有多个队列**，为了保证发送有序，RocketMQ提供了MessageQueueSelector（消息队列选择器）队列选择机制，他有三种实现：

![]( https://raw.githubusercontent.com/jingdomaaa/Java-learning-record/master/image/MQ/MQ_problem_solving5.png )

- 我们可使用**Hash取模法**，让同一个订单发送到同一个队列中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息。这样，我们保证了发送有序。
- **RocketMQ**的topic内的队列机制，可以保证储存满足**FIFO**（first input first output先进先出），剩下的只要消费者顺序消费就行。
- **RocketMQ**仅保证顺序发送，顺序消费由消费者业务保证。
- 这里很好理解，一个订单发送的时候放到一个队列里面去，同一个的订单号**Hash**一下是不是还是一样的结果，那肯定是一个消费者消费，那顺序就保证了。
- 真正的顺序消费不同的中间件都有·自己的不同实现，在这里就举个例子，方便思路理解。
- 那有人可能会想一个队列有序出去，一个消费者消费不就好了，但是**消费者是多线程的**，消息是有序给他的，但你可以保证他是有序处理的吗？所以还是一个消费成功了再发下一个稳妥。

## 分布式事务

- 分布式事务在现在遍地都是分布式部署的系统中几乎是必要的。

### 什么是事务

- **分布式事务、事务隔离级别、ACID**我相信大家这些东西已经耳熟能详了，那什么是事务呢？

- **概念：**

  > **一般是指要做的或所做的事情。**
  >
  > 在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元（unit）。
  >
  > 事务通常由高级数据库操纵语言或编程语言（如SQL、C++和Java）书写的用户程序的执行 所引起的，并用形如**begin transaction**和**end transaction**语句（或函数调用）来界定。
  >
  > 事务由事务开始(**begin transaction**)和事务结束(**end transaction**)之间执行的全体操纵组成。

- **特性：**

  > 事务是**恢复**和**并发控制**的基本单位。
  >
  > 事务应该具有四个属性：**原子性、一致性、隔离性、持久性。**这四个属性通常称为**ACID特性**。
  >
  > **原子性（atomicity）**：一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。
  >
  > **一致性（consistency）**：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
  >
  > **持久性（durability）**：**持久性也成永久性（permanence）**，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

- 总结来说就是：**事务就是一系列操作，要么同时成功，要么同时失败。**然后会从事务的**ACID特性（原子性，一致性，隔离性，持久性）展开叙述**。
- 事务就是为了保证一系列操作可以正常执行，它必须同时满足**ACID特性**。

### 什么是分布式事务

- 大家可以想一下，下单流程可能涉及到10多个环节，用户下单付钱都成功了，但是优惠券扣减失败了，积分新增失败了，前者公司被薅羊毛，后者用户会不开心，但是**这些都在不同的服务**，怎么保证大家都成功呢？
- **分布式事务**
- Tip：真实的应用场景可能比我介绍的场景复杂数倍，我只是为了举例方便理解，所以用了很简单的例子。

### 有哪些分布式事务

- 我接触和了解到的分布式事务大概分为：
  - 2pc（两段式提交）
  - 3pc（三段式提交）
  - TCC（Try, Confirm, Cancel  尝试，确认，取消 ）
  - 最大努力通知
  - XA
  - 本地消息表（eBay研发出的）
  - 半消息/最终一致性(RocketMQ)
- 这里我就介绍下最简单的2pc，以及大家以后可能比较常用的**半消息事务**也就是**最终一致性**，目的是让大家理解下分布式事务里面消息中间件的作用，别的事务都大同小异，都有很多优点。
- 当然也有**种种弊端**：
  - **长时间锁定数据库资源**，导致系统**响应不快，并发上不去。**
  - 网络抖动出现**脑裂**情况，导致事务参与者不能很好地执行协调者的指令，导致**数据不一致**。
  - **单点故障**：例如事务协调者，在某一时刻宕机，虽然可以通过选举机制产生新的Leader，但是这过程中，必然出现问题，而TCC只有强悍的技术团队才能支持开发，**成本太高**。

#### **2pc（两段式提交）**：

![]( https://raw.githubusercontent.com/jingdomaaa/Java-learning-record/master/image/MQ/MQ_problem_solving6.png )

- **2pc（两段式提交）**可以说是分布式事务最开始的样子了，像极了**媒婆**，就是通过中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。
- 但是如果A系统提交成功了，但是B系统在提交的时候网络波动或者各种原因提交失败了，其实还是会失败的。

#### 半消息/最终一致性（RocketMQ）：

![]( https://raw.githubusercontent.com/jingdomaaa/Java-learning-record/master/image/MQ/MQ_problem_solving7.png )

- 整个流程我们能保证的是：
  - 业务主动方本地事务提交失败，业务被动方不会收到消息的投递。
  - 只要业务主动方本地事务执行成功，那么消息服务一定会投递消息给下游的业务被动方，并最终保证业务被动方一定能成功消费该消费（消费成功或失败，即最终一定会有一个最终态）。

- 不过呢技术就是这样，**各种极端的情况我们都需要考虑**，也很难有完美的方案，所以才会有这么多的方案，**三段式，TCC，最大努力通知**等等分布式事务方案，大家只需要知道为什么要做，做了有什么好处，有什么坏处，在实际开发的时候注意下就好了，**系统是根据业务场景设计出来的，离开业务的技术没有意义，离开业务的技术没有底气。**